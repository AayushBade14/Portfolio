<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Aayush Bade's Portfolio Website">

    <title>Aayush Bade</title>
    
    <link href="../../../assets/icons/icon.png" rel="icon" type="image/png">
    <link href="part2.css" rel="stylesheet">
    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
      onload="renderMathInElement(document.body, {
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '\\(', right: '\\)', display: false }
          ]
      });">
    </script>
  </head>
  <body>
    <main>
      <nav>
        <div class="logo"><a href="../../../index.html">Aayush Bade</a></div>
        <div class="socials">
          <a href="https://github.com/AayushBade14" target="_blank"><img src="../../../assets/socials/github.png" alt="github-logo" loading="lazy" draggable="false"/></a>
          <a href="https://www.linkedin.com/in/aayush-raju-bade-b268b2280/" target="_blank"><img src="../../../assets/socials/linkedin.png" alt="linkedin-logo" loading="lazy" draggable="false"/></a>
          <a href="https://x.com/AayushBade14" target="_blank"><img src="../../../assets/socials/twitter.png" alt="twitter-logo" loading="lazy" draggable="false"/></a>
          <a href="https://youtube.com/@aayushrajubade" target="_blank"><img src="../../../assets/socials/youtube.png" alt="youtube-logo" loading="lazy" draggable="false"/></a>
          <a href="https://medium.com/@aayushrajubade" target="_blank"><img src="../../../assets/socials/medium.png" alt="medium-logo" loading="lazy" draggable="false"/></a>
          <a href="https://www.artstation.com/aayushbade" target="_blank"><img src="../../../assets/socials/artstation.png" alt="artstation-logo" loading="lazy" draggable="false"/></a>
        </div>
      </nav>
      <div class="intro">
        <div class="navigator">
          <a href="../../../index.html">Home</a> :: <a href="../../../pages/blogs/blogs.html">Blogs</a> :: <a href="../index.html">OpenGL Concepts</a>
        </div>
        <h1>2. Viewing in graphics - <span>The Orthographic Projection</span></h1>
        <hr noshade>
        <br>
        <br>
        <p>Now that we've understood all the stages that are involved in the <span>Viewing in graphics</span>. We can move ahead to the meat of this and actually start unravelling the math involved. We will skip the model-matrix transforms that if you don't remember, brings an object from the local/object-space to the global/world-space. As that will be covered in the later sections of this series where we will learn about transforms that move/scale/rotate the objects. For viewing I'm assuming you already know how the translate and scale transform works, as this will be used in the derivation of viewing concepts. I wanted to cover viewing first, I know this is a weird order, but just bear with me!</p>
        <br>
        <p>So, before we can get to the <span>Orthographic Projection</span> we need to understand how a basic <b>Windowing transformation</b> in 2D works. This is nothing but say we have a window - \(w1\) with bottom-left-corner having coordinates \((x_l,y_l)\) and top-right-corner having coordinates \((x_h, y_h)\) & we want to transform it into another window - \(w2\) with bottom-left-corner having coordinates \((x_l',y_l')\) and top-right-corner having coordinates \((x_h',y_h')\). Take a look at <a href="#fig-2.1">Fig-2.1</a></p>
        <div class="figure" id="fig-2.1">
          <img src="../assets/window_transform.jpg"/>
          <h5>Fig-2.1</h5>
        </div>
        <br>
        <br>
        <p>Now, that we've defined the problem, we can solve this using 3 simple steps.<br>1. <span>Step-1</span>: Translating window - \(w1\)'s left-bottom-corner to the orign.<br>2. <span>Step-2</span>: Scaling window - \(w1\) to the size of window - \(w2\).<br>3. <span>Step-3</span>: Translating window - \(w1\)'s left-bottom-corner to the position of window - \(w2\)'s left-bottom-corner.</p>
        <br>
        <br>
        <h3><b>1. Step-1</b></h3>
        <p>To bring the bottom-left-corner of window - \(w1\) to the origin - \((0,0)\), we'll subtract \((x_l,y_l)\) from each of the coordinates of the points of window - \(w1\). This will make the top-right-corner coordinate - \((x_h - x_l, y_h - y_l)\). This can be put up into a 2d-homogenous / \(3 \times 3\) translation matrix as follows: </p>
        <br>
        <br>
        $$
        T_1 = 
        \begin{pmatrix}
        1 & 0 & -x_l \\
        0 & 1 & -y_l \\
        0 & 0 & 1
        \end{pmatrix}
        $$
        <br>
        <br>
        <p>Take a look at <a href="#fig-2.2">Fig-2.2</a></p>
        <br>
        <br>
        <div class="figure" id="fig-2.2">
          <img src="../assets/window_transform_translate.jpg"/>
          <h5>Fig-2.2</h5>
        </div>
        <br>
        <br>
        <h3><b>2. Step-2</b></h3>
        <br>
        <br>
        <h3><b>3. View/Eye/Camera Space</b></h3>
        <p>We apply something known as the View/Eye/Camera transformation to our little-vertices in the world/global space to bring them to something known as the View/Eye/Camera space. Let's call it View-space so that I don't have to oblique every other alternative name... lol. In this space we transform all other vertices so that they would appear as if they are viewed from the lens of our virtual camera in our virtual world. This ain't so complex, We just compute each vertex position w.r.t the camera position. There are some more details to it as well, but that's a discussion for the next part of this blog series.</p>
        <br>
        <br>
        <h3><b>4. Canonical View Volume</b></h3>
        <p>After we have everything set as seen from the lens of our virtual camera. We apply something known as a projection, which transforms our view-volume of the virtual camera into something known as a <span>Canonical View Volume</span> which is nothing but a standardized format for the view-volume in which: </p>
        $$
        \begin{array}{l}
        X \: \in [ \: -1, \: 1 ] \\
        Y \: \in [ \: -1, \: 1 ] \\
        Z \: \in [ \: 0, \: 1 ] \\
        \end{array}
        $$
        <br>
        <p>It's not necessary but it's what everyone in the graphics community agrees to and it's now a standard-convention that we use and the benefit of reducing the view-volume to a smaller canonical view-volume is simple, it reduces the range of values we've to work with and it's more convinient. You might be wondering "What in the hell is this view-volume?" Bear with me, i'm just about to explain this. The view volume is the spaces which your virtual-camera can actuall see, anything outside this volume is clipped, or isn't visible on your screen. Voila! It's that simple ;)</p>
        <br>
        <br>
        <h3><b>5. Viewport Transform</b></h3>
        <p>After everything is down to the canonical-view-volume, we've only a single step remaining, we just project or squeeze this canonical-view-volume onto our viewport(Image/Window/Framebuffer) this maps our 3D canonical-view-volume to our 2D-Rectangle(screen/window) and we finally get the integer-coordinates for our individual pixel to be lit for that particlar vertex. And then our rasterizer figures out that this pixel needs to be coloured and then it runs a fragment-shader for each of these pixels, finally giving color to each of those pixels depending on the constraints specified in the fragment-shader.</p>
        <br>
        <br>
        <p>NEXT-BLOG: <a href="#">2. Viewing in graphics - The Orthographic Projection</a></p>
        <br>
        <br>
      </div>
      
      <footer>
          <p>&copy; 2025 Aayush Bade. All rights reserved.</p>
      </footer>
      
    </main>
  </body>
</html>





